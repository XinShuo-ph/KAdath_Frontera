/*
    Copyright 2017 Philippe Grandclement

    This file is part of Kadath.

    Kadath is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Kadath is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Kadath.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __SPHERIC_HPP_
#define __SPHERIC_HPP_

#define STD_TYPE 0 
#define LOG_TYPE 1
#define SURR_TYPE 2

#include "point.hpp"
#include "space.hpp"

namespace Kadath {

class Domain_shell_log ;
class Domain_shell_surr ;
class Term_eq ;
class Metric ;

/**
* Class for a spherical domain containing the origin and a symmetry with respect to the plane \f$ z=0 \f$.
* \li 3 dimensions.
* \li centered on the point \c center \f$(X_c, Y_c, Z_c)\f$
* \li The numerical coordinates are :
*
* \f$ 0 \leq x \leq 1 \f$
*
* \f$ 0 \leq \theta^\star \leq \pi/2 \f$
*
* \f$ 0 \leq \varphi^\star < 2\pi \f$
*
* \li Standard spherical coordinates :
*
* \f$ r = \alpha x \f$
*
* \f$ \theta = \theta^\star \f$
*
* \f$ \varphi = \varphi^\star \f$
*
* \li Standard Cartesian coordinates :
*
* \f$ X = r \sin\theta \cos\varphi + Xc \f$
*
* \f$ Y = r \sin\theta \sin\varphi + Yc \f$
*
* \f$ Z = r \cos\theta + Zc \f$
* \ingroup domain
*/
class Domain_nucleus : public Domain {

 private:
  double alpha ; ///< Relates the numerical to the physical radii.
  Point center ; ///< Absolute coordinates of the center.
 
 public: 
  /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param radius : radius of the nucleus.
  * @param cr : center of the spherical coordinates.
  * @param nbr : number of points in each dimension.
  */
  Domain_nucleus (int num, int ttype, double radius, const Point& cr, const Dim_array& nbr) ;
  Domain_nucleus (const Domain_nucleus& so) ; ///< Copy constructor.
  /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_nucleus (int num, FILE* ff) ;

  virtual ~Domain_nucleus() ;
  virtual void save (FILE*) const ;

  private: 
    virtual void do_absol ()  const ;
    virtual void do_cart ()  const ;
    virtual void do_cart_surr () const ;
    virtual void do_radius () const ;
  private:
    /**
    * Sets the base to the standard one for Chebyshev polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ T_{2i} (x)\f$ for \f$ l \f$ even and \f$ T_{2i+1} (x)\f$ for \f$ l \f$ odd.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_cheb_base(Base_spectral& so) const ;       
   /**
    * Sets the base to the standard one for Legendre polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ P_{2i} (x)\f$ for \f$ l \f$ even and \f$ P_{2i+1} (x)\f$ for \f$ l \f$ odd.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_legendre_base(Base_spectral& so) const ;
 /**
    * Sets the base to the standard one for Chebyshev polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{2i+1} (x)\f$ for \f$ l \f$ even and \f$ T_{2i} (x)\f$ for \f$ l \f$ odd.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_anti_cheb_base(Base_spectral& so) const ;       
    /**
    * Sets the base to the standard one for Legendre polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{2i+1} (x)\f$ for \f$ l \f$ even and \f$ T_{2i} (x)\f$ for \f$ l \f$ odd.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_anti_legendre_base(Base_spectral& so) const ;  

     virtual void set_cheb_base_r_spher(Base_spectral&) const ;
     virtual void set_cheb_base_t_spher(Base_spectral&) const ;
     virtual void set_cheb_base_p_spher(Base_spectral&) const ;
     virtual void set_cheb_base_r_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_t_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_p_mtz(Base_spectral&) const ;
  
     virtual void set_legendre_base_r_spher(Base_spectral&) const ;
     virtual void set_legendre_base_t_spher(Base_spectral&) const ;
     virtual void set_legendre_base_p_spher(Base_spectral&) const ;
     virtual void set_legendre_base_r_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_t_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_p_mtz(Base_spectral&) const ;

     virtual void set_cheb_r_base(Base_spectral&) const ;       
     virtual void set_legendre_r_base(Base_spectral&) const ;
     
     virtual void do_coloc () ;
     virtual int give_place_var (char*) const ;
  public:
    virtual double get_rmax() const {return alpha ; } ;
    virtual Point get_center () const {return center ;} ;

  
     virtual bool is_in(const Point&xx, double prec=1e-13) const ;
    /**
     * Computes the numerical coordinates from the physical ones.
     * \li \f$ x = \displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2+(Z-Z_c)^2}}{\alpha} \f$
     * \li \f$ \theta^\star = {\rm atan} (\displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2}}{Z-Z_c}) \f$
     * \li \f$ \varphi^\star = {\rm atan} (\displaystyle\frac{Y-Y_c}{Z-Z_c}) \f$
     * @param xxx [input] : the absolute Cartesian \f$ (X, Y, Z) \f$ coordinates of the point.
     * @returns the numerical coordinates \f$ (x, \theta^\star, \varphi^\star) \f$.
     */
     virtual const Point absol_to_num(const Point&) const;
     
     virtual const Point absol_to_num_bound(const Point&, int) const;
      
    /**
     * Computes the derivative with respect to the absolute Cartesian coordinates from the 
     * derivative with respect to the numerical coordinates.
     * \li \f$ \displaystyle\frac{\partial f}{\partial X} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \cos\varphi
     * - \sin\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Y} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \sin\varphi
     * + \cos\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Z} = 
     * \cos\theta \displaystyle\frac{\partial f}{\alpha\partial x} 
     * - \sin\theta\displaystyle\frac{\partial f}{r\partial \theta^\star}\f$
     * @param der_var [input] : the \c ndim derivatives with respect to the numerical coordinates.
     * @param der_abs [output] : the \c ndim derivatives with respect to the absolute Cartesian coordinates.
     */
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;

     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:
    
     virtual Val_domain mult_cos_phi (const Val_domain&) const ;
     virtual Val_domain mult_sin_phi (const Val_domain&) const ;
     virtual Val_domain mult_cos_theta (const Val_domain&) const ;
     virtual Val_domain mult_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_sin_theta (const Val_domain&) const ;  
     virtual Val_domain div_cos_theta (const Val_domain&) const ;
   
     virtual Tensor change_basis_cart_to_spher (int dd, const Tensor&) const ;
     virtual Tensor change_basis_spher_to_cart (int dd, const Tensor&) const ;

   
     virtual Val_domain div_x (const Val_domain&) const ;     
     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
     virtual Val_domain ddp (const Val_domain&) const ;
     virtual Val_domain srdr (const Val_domain&) const ;
     virtual Val_domain div_1mx2 (const Val_domain&) const ; 
     virtual Val_domain laplacian2 (const Val_domain&, int) const ;

     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     virtual void find_other_dom (int, int, int&, int&) const ;
     virtual Val_domain der_normal (const Val_domain&, int) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @param mlim: limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param llim: limit for the regularity (quantum number wrt \f$\theta\f$).
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so, int mlim, int llin) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* Intended for the radial component of a vector.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain_vr (const Val_domain& so) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* Intended for the \f$\theta\f$ component of a vector.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain_vt (const Val_domain& so) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* Intended for the \f$\theta\f$ component of a vector.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain_vp (const Val_domain& so) const ;
     
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param llim : limit for the regularity (quantum number wrt \f$\theta\f$).
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int mlim, int llim, int order) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* Intended for the radial component of a vector.
	* @param so : the residual of the equation
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain_vr (const Val_domain& so, int order) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* Intended for the \f$\theta\f$ component of a vector.
	* @param so : the residual of the equation
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain_vp (const Val_domain& so, int order) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* Intended for the \f$\varphi\f$ component of a vector.
	* @param so : the residual of the equation
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain_vt (const Val_domain& so, int order) const ;
     
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @param mlim : mimit for the regularity (quantum number wrt \f$\varphi\f$).
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& so, int mlim) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* Intended for a radial component of a vector.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary_vr (const Val_domain&) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* Intended for a \f$\theta\f$ component of a vector.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary_vt (const Val_domain&) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* Intended for a \f$\varphi\f$ component of a vector.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary_vp (const Val_domain&) const ;
     
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,  int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param llim : limit for the regularity (quantum number wrt \f$\theta\f$).
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int mlim, int llim, int order, Array<double>& res, int& pos_res, int ncond) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* Intended for a radial component of a vector.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain_vr (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* Intended for a \f$\theta\f$ component of a vector.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain_vt (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* Intended for a \f$\varphi\f$ component of a vector.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain_vp (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
       
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int mlim, int bound, Array<double>& res, int& pos_res, int ncond) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* Intended for the radial component of a vector/
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary_vr (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* Intended for the radial component of a vector/
	* @param eq : the \f$\theta\f$ of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary_vt (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* Intended for the radial component of a vector/
	* @param eq : the \f$\varphi\f$ of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond : the corresponding number of equations. It is used when the residual is null.
	*/
	void export_tau_val_domain_boundary_vp (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param llim : limit for the regularity (quantum number wrt \f$\theta\f$).
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, int mlim, int llim, const Array<double>& cf, int& pos_cf) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the radial component of a vector.
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain_vr (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the \f$\theta\f$ component of a vector.
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain_vt (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the \f$\varphi\f$ component of a vector.
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain_vp (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
      
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param llim : limit for the regularity (quantum number wrt \f$\theta\f$).
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int mlim, int llim, int cc, int& pos_cf) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the radial component of a vector.
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain_vr (Val_domain& so, int cc, int& pos_cf) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the \f$\theta\f$ component of a vector.
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain_vt (Val_domain& so, int cc, int& pos_cf) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* Intended for the \f$\varphi\f$ component of a vector.
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain_vp (Val_domain& so, int cc, int& pos_cf) const ;
	     
     virtual int nbr_points_boundary (int, const Base_spectral&) const ;
     virtual void do_which_points_boundary (int, const Base_spectral&, Index**, int) const ;
     
     virtual double integ_volume (const Val_domain& so) const ;
     
     virtual Term_eq derive_flat_spher (int, char, const Term_eq&, const Metric*) const ;
     virtual Term_eq derive_flat_cart (int, char, const Term_eq&, const Metric*) const ;
     virtual double integ(const Val_domain& so, int bound) const ;
     virtual Tensor import (int, int, int, const Array<int>&,  Tensor**) const ;
 
public:
     virtual ostream& print (ostream& o) const ;
} ;
/**
* Class for a spherical shell and a symmetry with respect to the plane \f$ z=0 \f$.
* \li 3 dimensions.
* \li centered on the point \c center \f$(X_c, Y_c, Z_c)\f$
* \li The numerical coordinates are :
*
* \f$ -1 \leq x \leq 1 \f$
*
* \f$ 0 \leq \theta^\star \leq \pi/2 \f$
*
* \f$ 0 \leq \varphi^\star < 2\pi \f$
*
* \li Standard spherical coordinates :
*
* \f$ r = \alpha x + \beta \f$
*
* \f$ \theta = \theta^\star \f$
*
* \f$ \varphi = \varphi^\star \f$
*
* \li Standard Cartesian coordinates :
*
* \f$ X = r \sin\theta \cos\varphi + Xc \f$
*
* \f$ Y = r \sin\theta \sin\varphi + Yc \f$
*
* \f$ Z = r \cos\theta + Zc \f$
* \ingroup domain
*/
class Domain_shell : public Domain {
   
 private:
  double alpha ; ///< Relates the numerical to the physical radii.
  double beta ; ///< Relates the numerical to the physical radii.
  Point center ; ///< Absolute coordinates of the center.
 
 public:  
 /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param r_int : inner radius of the shell.
  * @param r_ext : outer radius of the shell.
  * @param cr : center of the spherical coordinates.
  * @param nbr : number of points in each dimension.
  */
  Domain_shell (int num, int ttype, double r_int, double r_ext, const Point& cr, const Dim_array& nbr) ;
  Domain_shell (const Domain_shell& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_shell (int num, FILE* ff) ; 

  virtual ~Domain_shell() ; 
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;
    virtual void do_radius () const ; 
    virtual void do_cart () const ; 
    virtual void do_cart_surr () const ; 
  private :
   /**
    * Sets the base to the standard one for Chebyshev polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_cheb_base(Base_spectral&) const ;  
   /**
    * Sets the base to the standard one for Legendre polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ P_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_legendre_base(Base_spectral&) const ;
   /**
    * Sets the base to the standard one for Chebyshev polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_anti_cheb_base(Base_spectral&) const ;      
   /**
    * Sets the base to the standard one for Legendre polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */   
     virtual void set_anti_legendre_base(Base_spectral&) const ;     

     virtual void set_cheb_base_r_spher(Base_spectral&) const ;
     virtual void set_cheb_base_t_spher(Base_spectral&) const ;
     virtual void set_cheb_base_p_spher(Base_spectral&) const ;
     virtual void set_cheb_base_r_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_t_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_p_mtz(Base_spectral&) const ;
   
     virtual void set_legendre_base_r_spher(Base_spectral&) const ;
     virtual void set_legendre_base_t_spher(Base_spectral&) const ;
     virtual void set_legendre_base_p_spher(Base_spectral&) const ;
     virtual void set_legendre_base_r_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_t_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_p_mtz(Base_spectral&) const ;
   
     virtual void set_cheb_r_base(Base_spectral&) const ;       
     virtual void set_legendre_r_base(Base_spectral&) const ;
     
     virtual void do_coloc () ;

     virtual int give_place_var (char*) const ;
  public:     
    virtual double get_rmin() const {return beta - alpha ;} ;
    virtual double get_rmax() const {return beta+alpha ; } ;
    
    virtual Point get_center () const {return center ;} ; 
    virtual bool is_in(const Point& xx, double prec=1e-13) const ;
    /**
     * Computes the numerical coordinates from the physical ones.
     * \li \f$ x = \displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2+(Z-Z_c)^2}-\beta}{\alpha} \f$
     * \li \f$ \theta^\star = {\rm atan} (\displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2}}{Z-Z_c}) \f$
     * \li \f$ \varphi^\star = {\rm atan} (\displaystyle\frac{Y-Y_c}{Z-Z_c}) \f$
     * @param xxx [input] : the absolute Cartesian \f$ (X, Y, Z) \f$ coordinates of the point.
     * @returns the numerical coordinates \f$ (x, \theta^\star, \varphi^\star) \f$.
     */
     virtual const Point absol_to_num(const Point&) const;
     
      virtual const Point absol_to_num_bound(const Point&, int) const;
     /**
     * Computes the derivative with respect to the absolute Cartesian coordinates from the 
     * derivative with respect to the numerical coordinates.
     * \li \f$ \displaystyle\frac{\partial f}{\partial X} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \cos\varphi
     * - \sin\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Y} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \sin\varphi
     * + \cos\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Z} = 
     * \cos\theta \displaystyle\frac{\partial f}{\alpha\partial x} 
     * - \sin\theta\displaystyle\frac{\partial f}{r\partial \theta^\star}\f$
     * @param der_var [input] : the \c ndim derivatives with respect to the numerical coordinates.
     * @param der_abs [output] : the \c ndim derivatives with respect to the absolute Cartesian coordinates.
     */
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;
   
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:   
    
     virtual Val_domain mult_cos_phi (const Val_domain&) const ;     
     virtual Val_domain mult_sin_phi (const Val_domain&) const ;
     virtual Val_domain mult_cos_theta (const Val_domain&) const ;
     virtual Val_domain mult_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_sin_theta (const Val_domain&) const ; 
     virtual Val_domain div_cos_theta (const Val_domain&) const ;
     
     virtual Tensor change_basis_cart_to_spher (int dd, const Tensor&) const ;
     virtual Tensor change_basis_spher_to_cart (int dd, const Tensor&) const ;

     virtual Val_domain div_xp1 (const Val_domain&) const ;
     virtual Val_domain div_1mrsL (const Val_domain&) const ;
     virtual Val_domain mult_1mrsL (const Val_domain&) const ;
     
     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
     virtual Val_domain der_partial_var (const Val_domain&, int) const ;
     virtual Val_domain ddp (const Val_domain&) const ;
     virtual Val_domain div_xm1 (const Val_domain&) const ;      
     virtual Val_domain mult_xm1 (const Val_domain&) const ;
     virtual Val_domain div_1mx2 (const Val_domain&) const ; 
     virtual Val_domain laplacian2 (const Val_domain&, int) const ;
     virtual Val_domain dt (const Val_domain&) const ;

     virtual double multipoles_sym (int, int, int, const Val_domain&, const Array<double>&) const ;   
     virtual double multipoles_asym (int, int, int, const Val_domain&, const Array<double>&) const ;   

     virtual Term_eq multipoles_sym (int, int, int, const Term_eq&, const Array<double>&) const ;     
     virtual Term_eq multipoles_asym (int, int, int, const Term_eq&, const Array<double>&) const ;

     virtual Term_eq radial_part_sym (const Space&, int, int, const Term_eq&, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&) const ; 
     virtual Term_eq radial_part_asym (const Space&, int, int, const Term_eq&, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&) const ;
     virtual Term_eq harmonics_sym (const Term_eq&, const Term_eq&, int, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&, const Array<double>&) const ;
     virtual Term_eq harmonics_asym (const Term_eq&, const Term_eq&, int, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&, const Array<double>&) const ;
     
  
     virtual Term_eq der_radial_part_sym (const Space&, int, int, const Term_eq&, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param& param), const Param&) const ;
     virtual Term_eq der_radial_part_asym (const Space&, int, int, const Term_eq&, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&) const ;
     virtual Term_eq der_harmonics_sym (const Term_eq&, const Term_eq&, int, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&, const Array<double>&) const ;
     virtual Term_eq der_harmonics_asym (const Term_eq&, const Term_eq&, int, Term_eq (*f) (const Space&, int, int, const Term_eq&, const Param&), const Param&, const Array<double>&) const ;
     virtual Term_eq der_multipoles_sym (int, int, int, const Term_eq&, const Array<double>&) const ;     
     virtual Term_eq der_multipoles_asym (int, int, int, const Term_eq&, const Array<double>&) const ;

	/**
	* Gives an matching of the spatial metric, based on homogeneous solutions of outgoing waves.
	* @param gamma : the metric.
	* @param omega : the angular velocity of the helical Killing vector.
	* @returns : the outgoing wave.
	*/
     Term_eq bc_waves (const Term_eq& gamma, const Term_eq& omega) const ;
	/**
	* Gives an matching of the spatial metric, based on homogeneous solutions of outgoing waves. \c Tensor version
	* @param dom : the domain (should be the same as num_dom)
	* @param gamma : the metric.
	* @param omega : the angular velocity of the helical Killing vector.
	* @param toinf : has to do where the matching is performed... (need to clarify that)
	* @returns : the outgoing wave.
	*/
     Tensor bc_waves (int dom, const Tensor& gamma, const double omega, bool toinf = true) const ;
     
 /**
    * Fit some field with a \f$1/r\f$ decay (\c Val_domain version).
    * @param so : the field to be fitted.
    * @param dim : the dimension.
    * @returns : the fit.
    */
    Val_domain fitschwarz (const Val_domain&, int) const ;

     /**
    * Fit some field with a \f$1/r\f$ decay (\c Term_eq version).
    * @param so : the field to be fitted.
    * @param dim : the dimension.
    * @returns : the fit.
    */
    Term_eq fitschwarz (const Term_eq&, int) const ;

     virtual void find_other_dom (int, int, int&, int&) const ;     
     virtual Val_domain der_normal (const Val_domain&, int) const ;
     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     
     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @param mlim: limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so, int mlim) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int mlim, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @param mlim : mimit for the regularity (quantum number wrt \f$\varphi\f$).
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& so, int mlim) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,  int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int mlim, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond : the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int mlim, int bound, Array<double>& res, int& pres_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, int mlim, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int mlim, int cc, int& pos_cf) const ;
     virtual void export_tau_boundary_exception (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, const Param&, int, 
							    const Tensor&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to one tensorial one on a given boundary, excepted for some coefficients where another equation is used.
	* @param eq : the residual of the equation.
	* @param mlim :  limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	* @param param : parameters describing the coefficients where the alternative condition is enforced.
	* @param type_exception : states which type of exception (value or derivative ; current domain or the other one). Highly specialized...
	* @param exception : the equation used for the alternative condition.
	* @returns the number of true conditions.
	*/
     void export_tau_val_domain_boundary_exception (const Val_domain& so, int mlim, int bound, Array<double>& res, int& pos_res, int ncond, const Param& param, 
		int type_exception, const Val_domain& exception) const ;
     
     virtual int nbr_points_boundary (int, const Base_spectral&) const ;
     virtual void do_which_points_boundary (int, const Base_spectral&, Index**, int) const ;
     virtual Tensor import (int, int, int, const Array<int>&,  Tensor**) const ;
     
     virtual double integ_volume (const Val_domain& so) const ;
     virtual Term_eq derive_flat_spher (int, char, const Term_eq&, const Metric*) const ;
     virtual Term_eq derive_flat_cart (int, char, const Term_eq&, const Metric*) const ;  
     virtual Term_eq derive_flat_mtz (int, char, const Term_eq&, const Metric*) const ;
     virtual double integ(const Val_domain& so, int bound) const ;
 
public:
     virtual ostream& print (ostream& o) const ;
          
     friend class Domain_shell_log ;
     friend class Domain_shell_surr ;
} ;

/**
* Class for a spherical compactified domain and a symmetry with respect to the plane \f$ z=0 \f$.
* \li 3 dimensions.
* \li centered on the point \c center \f$(X_c, Y_c, Z_c)\f$
* \li The numerical coordinates are :
*
* \f$ -1 \leq x \leq 1 \f$
*
* \f$ 0 \leq \theta^\star \leq \pi/2 \f$
*
* \f$ 0 \leq \varphi^\star < 2\pi \f$
*
* \li Standard spherical coordinates :
*
* \f$ r = \displaystyle\frac{1}{\alpha x -1}\f$
*
* \f$ \theta = \theta^\star \f$
*
* \f$ \varphi = \varphi^\star \f$
*
* \li Standard Cartesian coordinates :
*
* \f$ X = r \sin\theta \cos\varphi + Xc \f$
*
* \f$ Y = r \sin\theta \sin\varphi + Yc \f$
*
* \f$ Z = r \cos\theta + Zc \f$
* \ingroup domain
*/
class Domain_compact : public Domain {

 private:
  double alpha ; ///< Relates the numerical to the physical radii.
  Point center ; ///< Absolute coordinates of the center.

 public:
 /**
  * Standard constructor :
  * @param num : index of the domain, used by \c Space.
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param r_int [input] : inner radius of the shell.
  * @param cr [input] : center of the spherical coordinates.
  * @param nbr [nbr] : number of points in each dimension.
  */
  Domain_compact (int num, int ttype, double r_int, const Point& cr, const Dim_array& nbr) ;
  Domain_compact (const Domain_compact& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_compact (int num, FILE* ff) ;

  virtual ~Domain_compact() ; 
  virtual void save(FILE*) const ;

  private:    
    virtual void do_absol ()  const ;
    virtual void do_radius () const ; 
    virtual void do_cart () const ; 
    virtual void do_cart_surr () const ; 

  private:
   /**
    * Sets the base to the standard one for Chebyshev polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_cheb_base(Base_spectral&) const ;     
   /**
    * Sets the base to the standard one for Legendre polynomials.
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j \f$) 
    * and \f$ sin((2j+1) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j+1 \f$).
    * \li \f$ P_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */ 
     virtual void set_legendre_base(Base_spectral&) const ;
     /**
    * Sets the base to the standard one for Chebyshev polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */
     virtual void set_anti_cheb_base(Base_spectral&) const ;       
   /**
    * Sets the base to the standard one for Legendre polynomials for functions antisymetric in \f$ z=0 \f$
    * The bases are :
    * \li \f$ cos(m\varphi^\star)\f$ and \f$ sin(m\varphi^\star)\f$ .
    * \li \f$ cos((2j+1)\theta^\star)\f$ for \f$ m \f$ even (\f$ l = 2j+1 \f$) 
    * and \f$ sin((2j) \theta^\star)\f$ for \f$ m \f$ odd (\f$ l = 2j \f$).
    * \li \f$ T_{i} (x)\f$.
    *
    * If \c type_coloc changes, \c coloc is uupdated and the derivative members destroyed.
    * @param so [output] : the returned base.
    */   
     virtual void set_anti_legendre_base(Base_spectral&) const ;

     virtual void set_cheb_base_r_spher(Base_spectral&) const ;
     virtual void set_cheb_base_t_spher(Base_spectral&) const ;
     virtual void set_cheb_base_p_spher(Base_spectral&) const ;
     virtual void set_legendre_base_r_spher(Base_spectral&) const ;
     virtual void set_legendre_base_t_spher(Base_spectral&) const ;
     virtual void set_legendre_base_p_spher(Base_spectral&) const ;
     virtual void set_legendre_base_r_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_t_mtz(Base_spectral&) const ;
     virtual void set_legendre_base_p_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_r_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_t_mtz(Base_spectral&) const ;
     virtual void set_cheb_base_p_mtz(Base_spectral&) const ;

     virtual void set_cheb_r_base(Base_spectral&) const ;       
     virtual void set_legendre_r_base(Base_spectral&) const ;
     
     virtual void do_coloc()  ;
     virtual int give_place_var (char*) const ;
 public:      
    virtual Point get_center () const {return center ;} ; ///< Returns the center ;
    double get_alpha() const ///< Returns the \f$\alpha\f$
			{return alpha ;} ;

    /**
     * Check whether a point lies inside \c Domain.
     * @param xx [input] : the point.
     * @param prec [input] : precision of the computation (used when comparing doubles).
     * @returns a \c true if the point is in the domain and \c false otherwise.
     */ 
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;    
    /**
     * Computes the numerical coordinates from the physical ones.
     * \li \f$ x = 1 + \displaystyle\frac{1}{\alpha\sqrt{(X-X_c)^2+(Y-Y_c)^2+(Z-Z_c)^2}} \f$
     * \li \f$ \theta^\star = {\rm atan} (\displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2}}{Z-Z_c}) \f$
     * \li \f$ \varphi^\star = {\rm atan} (\displaystyle\frac{Y-Y_c}{Z-Z_c}) \f$
     * @param xxx [input] : the absolute Cartesian \f$ (X, Y, Z) \f$ coordinates of the point.
     * @returns the numerical coordinates \f$ (x, \theta^\star, \varphi^\star) \f$.
     */
     virtual const Point absol_to_num(const Point&) const;

      virtual const Point absol_to_num_bound(const Point&, int) const;
    /**
     * Computes the derivative with respect to the absolute Cartesian coordinates from the 
     * derivative with respect to the numerical coordinates. 
     * \li \f$ r\displaystyle\frac{\partial f}{\partial X} = 
     *		(-\sin\theta (x-1) \displaystyle\frac{\partial f}{\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \cos\varphi
     * - \sin\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ r\displaystyle\frac{\partial f}{\partial Y} = 
     *		(-\sin\theta (x-1) \displaystyle\frac{\partial f}{\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \sin\varphi
     * + \cos\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ r\displaystyle\frac{\partial f}{\partial Z} = 
     * -\cos\theta (x-1) \displaystyle\frac{\partial f}{\partial x} 
     * - \sin\theta\displaystyle\frac{\partial f}{r\partial \theta^\star}\f$
     * @param der_var [input] : the \c ndim derivatives with respect to the numerical coordinates.
     * @param der_abs [output] : the \c ndim derivatives with respect to the absolute Cartesian coordinates.
     */
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ; 
    /**
     * Method for the multiplication of two \c Base_spectral.
     * @returns the output base is undefined if the result is not implemented (i.e. if one tries to multiply 
     * cosines with Chebyshev polynomials for instance).
     */
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:    

     virtual Tensor change_basis_cart_to_spher (int dd, const Tensor&) const ;
     virtual Tensor change_basis_spher_to_cart (int dd, const Tensor&) const ;

  
  
     virtual Val_domain mult_cos_phi (const Val_domain&) const ;   
     virtual Val_domain mult_sin_phi (const Val_domain&) const ;
     virtual Val_domain mult_cos_theta (const Val_domain&) const ;
     virtual Val_domain mult_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_sin_theta (const Val_domain&) const ;   
     virtual Val_domain div_cos_theta (const Val_domain&) const ;
     virtual Val_domain div_xm1 (const Val_domain&) const ;      
     virtual Val_domain mult_xm1 (const Val_domain&) const ;          
     virtual Val_domain mult_r (const Val_domain&) const ;   
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain der_r (const Val_domain&) const ; 
     virtual Val_domain der_r_rtwo (const Val_domain&) const ;
     virtual Val_domain der_partial_var (const Val_domain&, int) const ;
     virtual Val_domain laplacian2 (const Val_domain&, int) const ;
     virtual Val_domain dt (const Val_domain&) const ;

     virtual void set_val_inf (Val_domain&, double) const ;    

     virtual void find_other_dom (int, int, int&, int&) const ;     
     virtual Val_domain der_normal (const Val_domain&, int) const ;
     virtual double integ (const Val_domain&, int) const ;

     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     virtual int nbr_points_boundary (int, const Base_spectral&) const ;
     virtual void do_which_points_boundary (int, const Base_spectral&, Index**, int) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @param mlim: limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so , int mlim) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& eq, int mlim, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @param mlim : mimit for the regularity (quantum number wrt \f$\varphi\f$).
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& eq, int mlim) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond : the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int mlim, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond : the corresponding number of equations. It is used when the equation is null. 
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int mlim, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, int mlim, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param mlim : limit for the regularity (quantum number wrt \f$\varphi\f$).
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int mlim, int cc, int& pos_cf) const ;
 
     virtual Tensor import (int, int, int, const Array<int>&,  Tensor**) const ;
     
     virtual double integ_volume (const Val_domain& so) const ;
     virtual Term_eq derive_flat_spher (int, char, const Term_eq&, const Metric*) const ;
     virtual Term_eq derive_flat_cart (int, char, const Term_eq&, const Metric*) const ;
 
public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
 * The \c Space_spheric class fills the space with one nucleus, several shells and a compactified domain, all centered on the same point.
 * \ingroup domain
 */
class Space_spheric : public Space {
     public:
	/**
     	* Standard constructor 
     	* @param ttype [input] : the type of basis.
	* @param cr [input] : absolute coordinates of the center.
	* @param nbr [input] : number of points in each domain.
	* @param bounds [input] : radii of the various shells (and also determines the total number of domains).
	* @param withzec [input] : use a compactified domain or not
	*/
	Space_spheric (int ttype, const Point& cr, const Dim_array& nbr, const Array<double>& bounds, bool withzec=true) ;
	
	/**
     	* Constructor with different resolution in each domain
     	* @param ttype [input] : the type of basis.
	* @param cr [input] : absolute coordinates of the center.
	* @param nbr [input] : number of points in each domain.
	* @param bounds [input] : radii of the various shells (and also determines the total number of domains).
	*/
	Space_spheric (int ttype, const Point& cr, Dim_array** nbr, const Array<double>& bounds) ;
	
	
	/**
	* Standard constructor that allows some shells to be of diffent type (\c Domain_shell_log or \c Domain_shell_surr)
	* @param ttype [input] : the type of basis.
	* @param cr [input] : absolute coordinates of the center.
	* @param nbr [input] : number of points in each domain.
	* @param bounds [input] : radii of the various shells (and also determines the total number of domains).
	* @param type_shells : type of the shells (STD, LOG, SURR)
	*/
	Space_spheric (int ttype, const Point& cr, const Dim_array& nbr, const Array<double>& bounds, const Array<int>& type_shells) ;

	Space_spheric (FILE*, bool withzec=true) ; ///< Constructor from a file
	virtual ~Space_spheric() ; ///< Destructor        
	virtual void save(FILE*) const ;

	/**
	* Sets a boundary condition at the inner radius of the innermost shell.
	* Intended for systems where the nucleus is not used.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the boundary condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_inner_bc (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Sets a boundary condition at the outer radius of the compactified domain.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the boundary condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_outer_bc (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be second order)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equation.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;	

	/**
	* Adds a matching condition, at all the interface present in a given system.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_matching (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Adds a bulk equation and two matching conditions.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the bulk equation.
	* @param rac : the string describing the first matching condition.
	* @param rac_der : the string describing the second matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/	
	void add_eq (System_of_eqs& syst, const char* eq, const char* rac, const char* rac_der, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be first order)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equation.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq_one_side (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be 0th order)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equations.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq_full (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;

	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be first order)
	* It also adds a matching condition at each interface
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equation.
	* @param rac : the string describing the matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq_one_side (System_of_eqs& syst, const char* eq, const char* rac, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds an equation being a volume integral in the whole computational space.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equation (should contain something like integvolume(f)=b)
	*/
	void add_eq_int_volume (System_of_eqs& syst, const char* eq) ;

	/**
	* Adds an equation being the value of some field at the origin.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the quantity that must be zero at the origin
	*/		
	void add_eq_ori (System_of_eqs& syst, const char* eq) ;
	/**
	* Adds an equation saying that one coefficient of a field is zero (in the first shell)
	* @param syst : the \c System_of_eqs.
	* @param f : the field
	* @param itarget : the index \f$r\f$ of the mode that must vanish.
	* @param jtarget : the index \f$\theta\f$ of the mode that must vanish.
	* @param ktarget : the index \f$\varphi\f$ of the mode that must vanish.
	*/
	void add_eq_mode_mid (System_of_eqs& syst, const char* f, int itarget, int jtarget, int ktarget) ;

	/**
	* Computes the surface integral at infinity.
	* @param so : the field to be integrated.
	* @returns the surface integral.
	*/
	double int_inf (const Scalar&) const ;

	virtual Array<int> get_indices_matching_non_std(int, int) const ;
} ;

/**
* Class for a spherical shell and a symmetry with respect to the plane \f$ z=0 \f$.
* A logarithmic mapping is used for the radial coordinate meaning that \f$ \log r = \alpha x + \beta \f$
* \ingroup domain
*/
class Domain_shell_log : public Domain_shell {


 public:  
	/**
	* Standard constructor :
	* @param num : index of the \c Domain.  
        * @param ttype : Chebyshev or Legendre type of spectral expansion.
	* @param r_int [input] : inner radius of the shell.	
	* @param r_ext [input] : outer radius of the shell.
	* @param cr [input] : center of the spherical coordinates.
	* @param nbr [nbr] : number of points in each dimension.
	*/
  Domain_shell_log (int num, int ttype, double r_int, double r_ext, const Point& cr, const Dim_array& nbr) ;
  Domain_shell_log (const Domain_shell_log& so) ; ///< Copy constructor.
/**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_shell_log (int num, FILE* ff) ;

  virtual ~Domain_shell_log() ;
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;
    virtual void do_radius () const ;
    virtual void do_cart () const ;
  
  public:     
    virtual double get_rmin() const {return exp(beta - alpha) ;} ;
    virtual double get_rmax() const {return exp(beta+alpha) ; } ;

  
    /**
     * Check whether a point lies inside \c Domain.
     * @param xx [input] : the point.
     * @param prec [input] : precision of the computation (used when comparing doubles).
     * @returns a \c true if the point is in the domain and \c false otherwise.
     */
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;
     
    /**
     * Computes the numerical coordinates from the physical ones.
     * \li \f$ x = \displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2+(Z-Z_c)^2}-\beta}{\alpha} \f$
     * \li \f$ \theta^\star = {\rm atan} (\displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2}}{Z-Z_c}) \f$
     * \li \f$ \varphi^\star = {\rm atan} (\displaystyle\frac{Y-Y_c}{Z-Z_c}) \f$
     * @param xxx [input] : the absolute Cartesian \f$ (X, Y, Z) \f$ coordinates of the point.
     * @returns the numerical coordinates \f$ (x, \theta^\star, \varphi^\star) \f$.
     */
     virtual const Point absol_to_num(const Point&) const;
     
      virtual const Point absol_to_num_bound(const Point&, int) const;
     
     /**
     * Computes the derivative with respect to the absolute Cartesian coordinates from the 
     * derivative with respect to the numerical coordinates.
     * \li \f$ \displaystyle\frac{\partial f}{\partial X} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \cos\varphi
     * - \sin\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Y} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \sin\varphi
     * + \cos\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Z} = 
     * \cos\theta \displaystyle\frac{\partial f}{\alpha\partial x} 
     * - \sin\theta\displaystyle\frac{\partial f}{r\partial \theta^\star}\f$
     * @param der_var [input] : the \c ndim derivatives with respect to the numerical coordinates.
     * @param der_abs [output] : the \c ndim derivatives with respect to the absolute Cartesian coordinates.
     */
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;

     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
    
     virtual Val_domain der_normal (const Val_domain&, int) const ;
   
     
public:
     virtual ostream& print (ostream& o) const ;    
} ;

/**
* Class for a spherical shell and a symmetry with respect to the plane \f$ z=0 \f$.
* A mapping in \f$ 1/r \f$ is used for the radial coordinate
* \ingroup domain
*/
class Domain_shell_surr : public Domain_shell {


 public:  
 /**
  * Standard constructor :
  * @param num : index of the current domain.
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param r_int [input] : inner radius of the shell.
  * @param r_ext [input] : outer radius of the shell.
  * @param cr [input] : center of the spherical coordinates.
  * @param nbr [nbr] : number of points in each dimension.
  */
  Domain_shell_surr (int num, int ttype, double r_int, double r_ext, const Point& cr, const Dim_array& nbr) ;
  Domain_shell_surr (const Domain_shell_surr&) ; ///< Copy constructor.
/**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_shell_surr (int num , FILE* ff) ;

  virtual ~Domain_shell_surr() ;
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;
    virtual void do_radius () const ;
    virtual void do_cart () const ;
  
  public:     
    virtual double get_rmin() const {return 1./(beta - alpha) ;} ;
    virtual double get_rmax() const {return 1./(beta+alpha) ; } ;

  
    /**
     * Check whether a point lies inside \c Domain.
     * @param xx [input] : the point.
     * @param prec [input] : precision of the computation (used when comparing doubles).
     * @returns a \c true if the point is in the domain and \c false otherwise.
     */
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;
     
    /**
     * Computes the numerical coordinates from the physical ones.
     * \li \f$ x = \displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2+(Z-Z_c)^2}-\beta}{\alpha} \f$
     * \li \f$ \theta^\star = {\rm atan} (\displaystyle\frac{\sqrt{(X-X_c)^2+(Y-Y_c)^2}}{Z-Z_c}) \f$
     * \li \f$ \varphi^\star = {\rm atan} (\displaystyle\frac{Y-Y_c}{Z-Z_c}) \f$
     * @param xxx [input] : the absolute Cartesian \f$ (X, Y, Z) \f$ coordinates of the point.
     * @returns the numerical coordinates \f$ (x, \theta^\star, \varphi^\star) \f$.
     */
     virtual const Point absol_to_num(const Point&) const;
     
      virtual const Point absol_to_num_bound(const Point&, int) const;
      
     /**
     * Computes the derivative with respect to the absolute Cartesian coordinates from the 
     * derivative with respect to the numerical coordinates.
     * \li \f$ \displaystyle\frac{\partial f}{\partial X} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \cos\varphi
     * - \sin\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Y} = 
     *		(\sin\theta \displaystyle\frac{\partial f}{\alpha\partial x} + 
     *	\cos\theta \displaystyle\frac{\partial f}{r\partial \theta^\star}) \sin\varphi
     * + \cos\varphi \displaystyle\frac{\partial f}{r\sin\theta \partial \varphi^\star} \f$
     * \li \f$ \displaystyle\frac{\partial f}{\partial Z} = 
     * \cos\theta \displaystyle\frac{\partial f}{\alpha\partial x} 
     * - \sin\theta\displaystyle\frac{\partial f}{r\partial \theta^\star}\f$
     * @param der_var [input] : the \c ndim derivatives with respect to the numerical coordinates.
     * @param der_abs [output] : the \c ndim derivatives with respect to the absolute Cartesian coordinates.
     */
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;

     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
    
     virtual Val_domain der_normal (const Val_domain&, int) const ;
   
     
public:
     virtual ostream& print (ostream& o) const ;     
    
} ;

}
#endif
