/*
    Copyright 2017 Philippe Grandclement

    This file is part of Kadath.

    Kadath is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Kadath is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Kadath.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __SPHERIC_PERIODIC_HPP_
#define __SPHERIC_PERIODIC_HPP_

#include "space.hpp"

#define TO_PI 0 
#define TO_PI_OVER_2 1
namespace Kadath {


/**
* Class for a 2-dimensional spherical domain containing the origin and a symetry with respect to the plane \f$ z=0 \f$.
* The second dimension is the time that is periodic.
* Time can have two possible behaviors where the numerical time goes either to \f$\pi\f$ or to \f$\pi/2\f$.
* In the first case standard fields are expanded onto cosines functions and onto even cosines in the second one.
*
* \li The numerical coordinates are :
*
* \f$ 0 \leq x \leq 1 \f$
*
* \f$ 0 \leq t^\star \leq \pi/2 \quad  {\rm or} \quad \pi\f$

* \li Standard spherical coordinates :
*
* \f$ r = \alpha x \f$
*
* \f$ t = t^\star / \omega\f$
*
* \ingroup domain
*/
class Domain_spheric_periodic_nucleus : public Domain {

 private:
  double alpha ; ///< Relates the numerical radius to the physical one.
  double ome ; ///< Relates the numerical time to the physical one.
  /**
   * Gives the type of time periodicity.
   * \li if 0 \f$ t^\star\f$ goes to \f$ \pi\f$.
   * \li if 1 \f$ t^\star\f$ goes to \f$ \pi/2\f$.
   */
  int type_time ;
  double maxt ; ///< Upper bound of \f$ t^\star\f$ which is \f$\pi\f$ or \f$\pi/2\f$.

 public: 
   /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param typet : type of time periodicity (to \f$\pi\f$ or \f$\pi/2\f$).
  * @param radius : radius of the nucleus.
  * @param ome : pulsation.
  * @param nbr : number of points in each dimension.
  */
  Domain_spheric_periodic_nucleus (int num, int ttype, int typet, double radius, double ome, const Dim_array& nbr) ;
  Domain_spheric_periodic_nucleus (const Domain_spheric_periodic_nucleus& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_spheric_periodic_nucleus (int num, FILE* ff) ;

  virtual ~Domain_spheric_periodic_nucleus() ;
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;

  private:
     virtual void set_cheb_base(Base_spectral&) const ;       
     virtual void set_legendre_base(Base_spectral&) const ;  
     virtual void set_anti_cheb_base(Base_spectral&) const ;       
     virtual void set_anti_legendre_base(Base_spectral&) const ; 
     virtual void set_cheb_base_odd(Base_spectral&) const ;       
     virtual void set_legendre_base_odd(Base_spectral&) const ;
     virtual void do_coloc () ;
     virtual void do_radius () const ;
  public:
     virtual bool is_in(const Point&xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point&) const;
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:
     virtual Val_domain div_x (const Val_domain&) const ;     
     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain laplacian (const Val_domain&, int) const ;
     virtual Val_domain der_r (const Val_domain&) const ; 
     virtual Val_domain srdr (const Val_domain&) const ;
     virtual Val_domain ddtime (const Val_domain&) const ;
     virtual Val_domain dtime (const Val_domain&) const ;

     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     virtual void find_other_dom (int, int, int&, int&) const ;
     virtual Val_domain der_normal (const Val_domain&, int) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;

	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& eq) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int cc, int& pos_cf) const ;

public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
* Class for a 2-dimensional spherical domain bounded between two fixed radii and a symetry with respect to the plane \f$ z=0 \f$.
* The second dimension is the time that is periodic.
* Time can have two possible behaviors where the numerical time goes either to \f$\pi\f$ or to \f$\pi/2\f$.
* In the first case standard fields are expanded onto cosines functions and onto even cosines in the second one.
*
* \li The numerical coordinates are :
*
* \f$ -1 \leq x \leq 1 \f$
*
* \f$ 0 \leq t^\star \leq \pi/2 \quad  {\rm or} \quad \pi\f$

* \li Standard spherical coordinates :
*
* \f$ r = \alpha x + \beta \f$
*
* \f$ t = t^\star / \omega\f$
*
* \ingroup domain
*/
class Domain_spheric_periodic_shell : public Domain {

 private:
  double alpha ; ///< Relates the numerical to the physical radii.
  double beta ; ///< Relates the numerical to the physical radii.
  double ome ; ///< Relates the numerical time to the physical one.
  /**
   * Gives the type of time periodicity.
   * \li if 0 \f$ t^\star\f$ goes to \f$ \pi\f$.
   * \li if 1 \f$ t^\star\f$ goes to \f$ \pi/2\f$.
   */
  int type_time ;
  double maxt ; ///< Upper bound of \f$ t^\star\f$ which is \f$\pi\f$ or \f$\pi/2\f$.

 public:  
   /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param typet : type of time periodicity (to \f$\pi\f$ or \f$\pi/2\f$).
  * @param r_int : inner radius.
  * @param r_ext : outer radius.
  * @param ome : pulsation.
  * @param nbr : number of points in each dimension.
  */
  Domain_spheric_periodic_shell (int num, int ttype, int typet, double r_int, double r_ext, double ome, const Dim_array& nbr) ;
  Domain_spheric_periodic_shell (const Domain_spheric_periodic_shell& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_spheric_periodic_shell (int num, FILE* ff) ;

  virtual ~Domain_spheric_periodic_shell() ;
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;

  private :
     virtual void set_cheb_base(Base_spectral&) const ;  
     virtual void set_legendre_base(Base_spectral&) const ;     
     virtual void set_anti_cheb_base(Base_spectral&) const ;       
     virtual void set_anti_legendre_base(Base_spectral&) const ; 
     virtual void set_cheb_base_odd(Base_spectral&) const ;       
     virtual void set_legendre_base_odd(Base_spectral&) const ;
     virtual void do_coloc () ;
     virtual void do_radius () const ;
  public:     
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point&) const;
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;
   
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:   
     virtual Val_domain mult_r (const Val_domain&) const ;
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain laplacian (const Val_domain&, int) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
     virtual Val_domain ddtime (const Val_domain&) const ;
     virtual Val_domain dtime (const Val_domain&) const ;
     virtual Val_domain div_xm1 (const Val_domain&) const ;
     
     virtual void find_other_dom (int, int, int&, int&) const ;     
     virtual Val_domain der_normal (const Val_domain&, int) const ;
     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     
     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& eq) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int cc, int& pos_cf) const ;

   /**
    * Computes the coefficient of a given outgoing wave harmonique inside some field, at the outer boundary of the domain.
    * @param so : the field to be fitted.
    * @param nn : index of the harmonic.
    * @param phase : the phase of the harmonic (uncontrained by the equation).
    * @param dim : the dimension.
    * @param fact : factor  in the homogeneous equation.
    * @returns : the amplitude of the wave.
    */
    double give_harmonique (const Val_domain& so, int nn, double phase, int dim, double fact) const ;
   /**
    * Fit some field with homogenous solutions of the wave equation (\c Val_domain version).
    * @param so : the field to be fitted.
    * @param phases : array containing the phases of each harmonic (uncontrained by the equation).
    * @param dim : the dimension.
    * @param fact : factor  in the homogeneous equation.
    * @returns : the fit, being a sum of outgoing waves.
    */
    Val_domain fitwaves (const Val_domain& so, const Array<double>& phases, int dim, double fact) const ;
    /**
    * Fit some field with homogenous solutions of the wave equation (\c Term_eq version).
    * @param so : the field to be fitted.
    * @param phases : array containing the phases of each harmonic (uncontrained by the equation).
    * @param dim : the dimension.
    * @param fact : factor  in the homogeneous equation.
    * @returns : the fit, being a sum of outgoing waves.
    */
    Term_eq fitwaves (const Term_eq& so, const Array<double>& phases, int dim, double fact) const ;
    
     /**
    * Fit some field with a \f$1/r\f$ decay (\c Val_domain version).
    * @param so : the field to be fitted.
    * @param dim : the dimension.
    * @returns : the fit.
    */
    Val_domain fitschwarz (const Val_domain&, int) const ;
     /**
    * Fit some field with a \f$1/r\f$ decay (\c Term_eq version).
    * @param so : the field to be fitted.
    * @param dim : the dimension.
    * @returns : the fit.
    */
    Term_eq fitschwarz (const Term_eq&, int) const ;
  
    /**
    * Computes the coefficient of a given outgoing wave harmonique inside some field, at the outer boundary of the domain.
    * Case of a field coupled to gravity.
    * @param so : the field to be fitted.
    * @param mass : mass factor
    * @param nn : index of the harmonic.
    * @param phase : the phase of the harmonic (uncontrained by the equation).
    * @param dim : the dimension.
    * @param fact :  factor  in the homogeneous equation.
    * @returns : the amplitude of the wave.
    */
    double give_harmonique_nonflat (const Val_domain& so, double mass, int nn, double phase, int dim, double fact) const ;
   /**
    * Fit some field with homogenous solutions of the wave equation (\c Term_eq version).
    * Case of a field coupled to gravity.
    * @param so : the field to be fitted.
    * @param field : the gravitational term.
    * @param phases : array containing the phases of each harmonic (uncontrained by the equation).
    * @param dim : the dimension.
    * @param fact : factor in the homogeneous equation.
    * @returns : the fit, being a sum of outgoing waves.
    */
    Term_eq fitwaves_nonflat (const Term_eq& so, const Term_eq& field, const Array<double>& phases, int dim, double factor) const;
  
  
public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
* Class for a 2-dimensional compactified spherical domain and a symetry with respect to the plane \f$ z=0 \f$.
* The second dimension is the time that is periodic.
* Time can have two possible behaviors where the numerical time goes either to \f$\pi\f$ or to \f$\pi/2\f$.
* In the first case standard fields are expanded onto cosines functions and onto even cosines in the second one.
*
* \li The numerical coordinates are :
*
* \f$ -1 \leq x \leq 1 \f$
*
* \f$ 0 \leq t^\star \leq \pi/2 \quad  {\rm or} \quad \pi\f$

* \li Standard spherical coordinates :
*
* \f$ r = \frac{1}{\alpha \left(x-1\right)} \f$
*
* \f$ t = t^\star / \omega\f$
*
* \ingroup domain
*/
class Domain_spheric_periodic_compact : public Domain {

 private:
  double alpha ; ///< Relates the numerical radius to the physical one.
  double ome ; ///< Relates the numerical time to the physical one.
  /**
   * Gives the type of time periodicity.
   * \li if 0 \f$ t^\star\f$ goes to \f$ \pi\f$.
   * \li if 1 \f$ t^\star\f$ goes to \f$ \pi/2\f$.
   */
  int type_time ;
  double maxt ; ///< Upper bound of \f$ t^\star\f$ which is \f$\pi\f$ or \f$\pi/2\f$.

 
 public:
   /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param typet : type of time periodicity (to \f$\pi\f$ or \f$\pi/2\f$).
  * @param r_int : inner radius.
  * @param ome : pulsation.
  * @param nbr : number of points in each dimension.
  */
  Domain_spheric_periodic_compact (int num, int ttype, int typet, double r_int, double ome, const Dim_array& nbr) ;
  Domain_spheric_periodic_compact (const Domain_spheric_periodic_compact& so) ; ///< Copy constructor.
  /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_spheric_periodic_compact (int num, FILE* ff) ;

  virtual ~Domain_spheric_periodic_compact() ;
  virtual void save(FILE*) const ;

  private:
     virtual void set_cheb_base(Base_spectral&) const ;     
     virtual void set_legendre_base(Base_spectral&) const ;     
     virtual void set_anti_cheb_base(Base_spectral&) const ;     
     virtual void set_anti_legendre_base(Base_spectral&) const ;     
     virtual void set_cheb_base_odd(Base_spectral&) const ;       
     virtual void set_legendre_base_odd(Base_spectral&) const ;

     virtual void do_coloc()  ;
     virtual void do_absol ()  const ; 
     virtual void do_radius () const ;

 public:      
    /**
     * @returns : the \f$ \alpha\f$ of the mapping.
     */
    double get_alpha() const {return alpha ;} ;

   
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;    
     virtual const Point absol_to_num(const Point&) const;
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ; 
    
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

  public:      
    
     virtual Val_domain div_xm1 (const Val_domain&) const ;      
     virtual Val_domain mult_xm1 (const Val_domain&) const ;          
     virtual Val_domain mult_r (const Val_domain&) const ;   
     virtual Val_domain div_r (const Val_domain&) const ;
     virtual Val_domain laplacian (const Val_domain&, int) const ;
     virtual Val_domain der_r (const Val_domain&) const ;
     virtual Val_domain ddtime (const Val_domain&) const ;
     virtual Val_domain dtime (const Val_domain&) const ;

     virtual void set_val_inf (Val_domain& so, double xx) const ;    

     virtual void find_other_dom (int, int, int&, int&) const ;     
     virtual Val_domain der_normal (const Val_domain&, int) const ;
     virtual double val_boundary (int, const Val_domain&, const Index&) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& eq) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int cc, int& pos_cf) const ;

public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
 * The \c Space_oned class fills the space with 2-dimensioanl domains : spherically symmetric and time periodic.
 * \ingroup domain
 */

class Space_spheric_periodic : public Space {
  
     protected:
	double omega ; ///< The pulsation of the space.
	
     public:
        /**
     	* Standard constructor 
     	* @param ttype [input] : the type of basis.	
        * @param typet [input] : type of time periodicity (to \f$\pi\f$ or \f$\pi/2\f$).
	* @param nbr [input] : number of points in each domain.
	* @param bounds [input] : radii of the various shells (and also determines the total number of domains).
	* @param ome [input] : the pulsation.
	*/
	Space_spheric_periodic (int ttype, int typet, const Dim_array& nbr, const Array<double>& bounds, double ome) ;
	Space_spheric_periodic (FILE*) ; ///< Constructor from a file.
	virtual ~Space_spheric_periodic() ;      
	virtual void save(FILE*) const ;

	/**
	* Sets a boundary condition at the outer radius of the compactified domain.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the boundary condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_outer_bc (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be second order)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equation.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds a bulk equation in all the domains of a given system (equation is assumed to be 0th order)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the equations.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq_full (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds a matching condition, at all the interface present in a given system.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_matching (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds a bulk equation and two matching conditions.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the bulk equation.
	* @param rac : the string describing the first matching condition.
	* @param rac_der : the string describing the second matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/	
	void add_eq (System_of_eqs& syst, const char* eq, const char* rac, const char* rac_der, int nused=-1, Array<int>** pused=0x0)  ; 
	/**
	* Adds a bulk equation and two matching conditions (from outer domains to inner ones)
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the bulk equation.
	* @param rac : the string describing the first matching condition.
	* @param rac_der : the string describing the second matching condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_eq_inverted (System_of_eqs& syst, const char* eq, const char* rac, const char* rac_der, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds an equation being the value of some field at the origin.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the quantity that must be zero at the origin
	*/
	void add_eq_ori (System_of_eqs& syst, const char* eq) ;
} ;
}
#endif
