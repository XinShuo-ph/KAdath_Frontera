//
// Created by sauliac on 20/03/2020.
//

#ifndef __DIM_ARRAY_ITERATOR_HPP_
#define __DIM_ARRAY_ITERATOR_HPP_

#include <vector>

#include "headcpp.hpp"
#include "dim_array.hpp"

namespace Kadath {
    /**
     * Version of the \c Index class optimized for incremental access to Array components.
     */
    class Dim_array_iterator : public Memory_mapped
    {
    public:
        using Steps_ptr_type = Dim_array::Steps_ptr_type ;

    protected:
        /**
        * Sizes of the associated \c Array.
        * When used with a \c Tensor, it is the dimension, for each tensorial index.
        */
        Dim_array const & sizes ;
        //! Number of dimensions.
        int ndim;
        //! The incremental index step with respect to each dimensions.
        Steps_ptr_type steps;
        int position; ///< Corresponding value for 1D indexing .

    public:
        /**Standard constructor.
        * All the positions are set to zero.
        * @param dim [input] Sizes in each dimensions.
        **/
        explicit Dim_array_iterator (const Dim_array& dim)
            : sizes{dim}, ndim{dim.get_ndim()}, steps{dim.get_steps()}, position{0} {}

        //Copy constructor and assignment operator, move constructor and assignment as well as the destructor are the
        // default ones generated by the compiler.
        /**
        * Returns the number of dimensions.
        */
        int get_ndim() const {return sizes.get_ndim() ;} ;
        //! Accessor for the \c value member.
        int get_position() const {return position;}

        void set_position(int _position) {position = _position;}

        bool operator==(Dim_array_iterator const & xx) const {
#ifdef ALL_CHECKS_ENABLED
            return (position == xx.position && steps == xx.steps);
#else
            return position == xx.position;
#endif
        }

        /**
         * Set the position of the iterator at the same as the one of the source.
         * @param _so iterator to copy the position from.
         * @return a reference toward the current object.
         */
        void set(Dim_array_iterator const &_so) {assert(steps == _so.steps); position = _so.position;}
        bool check_value();
        void set_start() { position = 0;}
        /**
        * Returns all the dimensions
        */
        Dim_array const& get_sizes() const {return sizes ;} ;
        /**
        * Increments the position of the \c Dim_array_iterator.
        * If one reaches the last point of a dimension, then the next one is increased.
        * @param increm [input] value of the increment.
        * @param var [input] dimension to be incremented.
        * @return \c false if the result is outside the \c Array and \c true otherwise.
        */
        bool inc (int increm, int var=0) { position += increm * (*steps)[var]; return check_value();}
        bool inc1(int var)  { position += (*steps)[var]; return check_value();}
        bool inc() {position++; return check_value(); }
        template <class> friend class Array ;
    };

    inline bool Dim_array_iterator::check_value() {
        auto const & _steps = *steps;
        if(position >= _steps[ndim]) {
            position = _steps[ndim] - 1;
            return false;
        }
        else return true;
    }

    inline Dim_array_iterator Dim_array::make_iterator(int init) const {return Dim_array_iterator{*this};}

}

#endif //__DIM_ARRAY_ITERATOR_HPP_
