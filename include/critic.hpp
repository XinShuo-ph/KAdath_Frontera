/*
    Copyright 2017 Philippe Grandclement

    This file is part of Kadath.

    Kadath is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Kadath is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Kadath.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __CRITIC_HPP_
#define __CRITIC_HPP_

#include "space.hpp"

namespace Kadath {

/**
* Class for a 2-dimensional cylindrical type domain.
* It is highly specialized and designed for critic pehnomenom study.
* 
* \li The numerical coordinates are :
*
* \f$ 0 \leq X \leq 1 \f$
*
* \f$ 0 \leq T^\star \leq \pi \f$

* \li Standard spherical coordinates :
*
* \f$ X = x_{\rm lim}  X^\star \f$
*
* \f$ T = T^\star \f$
*
* \ingroup domain
*/
class Domain_critic_inner : public Domain {

  protected:
    mutable Val_domain* p_X ; ///< Pointer on the \f$ X\f$ variable.
    mutable Val_domain* p_T ; ///< Pointer on the \f$ T\f$ variable.
    double xlim ; ///< Relates the numerical \f$ X^\star \f$ to the \f$ X\f$ variable.

 public:  
 /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param nbr : number of points in each dimension.
  * @param xl : \f$ x_{\rm lim} \f$.
  */
  Domain_critic_inner (int num, int ttype, const Dim_array& nbr, double xl) ;
  Domain_critic_inner (const Domain_critic_inner & so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_critic_inner (int num, FILE* ff) ;

  virtual ~Domain_critic_inner() ;
  void del_deriv() override;
  virtual void save (FILE*) const ;
   
  private : 
     virtual void set_cheb_base(Base_spectral& so) const ;
     virtual void set_legendre_base(Base_spectral&) const ;

     virtual void set_cheb_xodd_base(Base_spectral& so) const ;
     virtual void set_legendre_xodd_base(Base_spectral&) const ;     
     virtual void set_cheb_todd_base(Base_spectral& so) const ;
     virtual void set_legendre_todd_base(Base_spectral&) const ;
     virtual void set_cheb_xodd_todd_base(Base_spectral& so) const ;
     virtual void set_legendre_xodd_todd_base(Base_spectral&) const ;

     virtual void do_coloc () ;
     virtual int give_place_var (char*) const ;
     void do_X() const ; ///< Computes \f$ X\f$.
     void do_T() const ; ///< Computes \f$ T\f$.

   public:
     virtual const Val_domain & get_X() const ;
     virtual const Val_domain & get_T() const ;
     virtual Val_domain div_x (const Val_domain&) const ;     
     
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point& xxx) const ;
     virtual void do_absol () const ;

  public:  
     virtual void find_other_dom (int, int, int&, int&) const ;
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;
     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     virtual Val_domain der_partial_var (const Val_domain&, int) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
       /**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/
     int nbr_conditions_val_domain_boundary (const Val_domain& eq) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int cc, int& pos_cf) const ;
      
     virtual int nbr_points_boundary (int, const Base_spectral&) const ;
     virtual void do_which_points_boundary (int, const Base_spectral&, Index**, int) const ;

public:
     virtual ostream& print (ostream& o) const ;
} ;


/**
* Class for a 2-dimensional cylindrical type domain.
* It is highly specialized and designed for critic pehnomenom study.
* 
* \li The numerical coordinates are :
*
* \f$ -1 \leq X \leq 1 \f$
*
* \f$ 0 \leq T^\star \leq \pi \f$

* \li Standard spherical coordinates :
*
* \f$ X = \left(1 - x_{\rm lim}\right)/2 X^\star +  \left(1 - x_{\rm lim}\right)/2 \f$
*
* \f$ T = T^\star \f$
*
* \ingroup domain
*/
class Domain_critic_outer : public Domain {

  protected:
    mutable Val_domain* p_X ; ///< Pointer on the \f$ X\f$ variable.
    mutable Val_domain* p_T ; ///< Pointer on the \f$ T\f$ variable.
    double xlim ; ///< Relates the numerical \f$ X^\star \f$ to the \f$ X\f$ variable.

 public:  
 /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param nbr : number of points in each dimension.
  * @param xl : \f$ x_{\rm lim} \f$.
  */
  Domain_critic_outer (int num, int ttype, const Dim_array& nbr, double xl) ;
  Domain_critic_outer (const Domain_critic_outer & so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_critic_outer (int num, FILE* ff) ;

  virtual ~Domain_critic_outer() ;   
  void del_deriv() override;
  virtual void save (FILE*) const ;
   
  private : 
     virtual void set_cheb_base(Base_spectral& so) const ;
     virtual void set_legendre_base(Base_spectral&) const ;
     virtual void set_cheb_todd_base(Base_spectral& so) const ;
     virtual void set_legendre_todd_base(Base_spectral&) const ;

     virtual void do_coloc () ;
     virtual int give_place_var (char*) const ;
     void do_X() const ; ///< Computes \f$ X\f$.
     void do_T() const ;///< Computes \f$ T\f$.

   public:
     virtual const Val_domain & get_X() const ;
     virtual const Val_domain & get_T() const ;
     
     virtual bool is_in(const Point& xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point& xxx) const ;
     virtual void do_absol () const ;

  public:  
     virtual void find_other_dom (int, int, int&, int&) const ;
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;
     virtual double val_boundary (int, const Val_domain&, const Index&) const ;
     virtual Val_domain der_partial_var (const Val_domain&, int) const ;

     virtual int nbr_unknowns (const Tensor&, int) const ;
	/**
	* Computes the number of true unknowns of a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions to determine the precise number of degrees of freedom.
	* @param so : the field.
	* @returns the number of true unknowns.
	*/
     int nbr_unknowns_val_domain (const Val_domain& so) const ;
     virtual Array<int> nbr_conditions (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Computes number of discretized equations associated with a given tensorial equation in the bulk.
	* It takes into account the various Galerkin basis used.
	* @param so : the residual of the equation.
	* @param order : order of the equation (i.e. 2 for a Laplacian for instance)
	* @returns the number of true unknowns.
	*/
     int nbr_conditions_val_domain (const Val_domain& so, int order) const ;
     virtual Array<int> nbr_conditions_boundary (const Tensor&, int, int, int n_cmp=-1, Array<int>** p_cmp=0x0) const ; 
      /**
	* Computes number of discretized equations associated with a given equation on a boundary.
	* It takes into account the various Galerkin basis used.
	* It is used for implementing boundary conditions and matching ones.
	* @param eq : the residual of the equation.
	* @returns the number of true conditions.
	*/ 
     int nbr_conditions_val_domain_boundary (const Val_domain& eq) const ;
     virtual void export_tau (const Tensor&, int, int, Array<double>&, int&, const Array<int>&,int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports a residual equation in the bulk.
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param order : describes the order of the equation (2 for a Laplacian for instance).
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the equation is null.
	*/
     void export_tau_val_domain (const Val_domain& eq, int order, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void export_tau_boundary (const Tensor&, int, int, Array<double>&, int&, const Array<int>&, int n_cmp=-1, Array<int>** p_cmp=0x0) const ;
	/**
	* Exports all the residual equations corresponding to a tensorial one on a given boundary
	* It makes use of the various Galerkin basis used.
	* @param eq : the residual of the equation.
	* @param bound : the boundary at which the equation is enforced.
	* @param res : The \c Array where the discretized equations are stored.
	* @param pos_res : current position in res.
	* @param ncond :  the corresponding number of equations. It is used when the residual is null.
	*/
     void export_tau_val_domain_boundary (const Val_domain& eq, int bound, Array<double>& res, int& pos_res, int ncond) const ;
     virtual void affecte_tau (Tensor&, int, const Array<double>&, int&) const ;
	/**
	* Affects some coefficients to a \c Val_domain.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the field to be affected.
	* @param cf : \c Array of the coefficients used.
	* @param pos_cf : current position in the array of coefficients.
	*/
     void affecte_tau_val_domain (Val_domain& so, const Array<double>& cf, int& pos_cf) const ;
     virtual void affecte_tau_one_coef (Tensor&, int, int, int&) const ;
	/**
	* Sets at most one coefficient of a \c Val_domain to 1.
	* It takes into account the various symmetries and regularity conditions (by means of Garlekin basis).
	* @param so : the \c Val_domain to be affected. It is set to zero if cc does not corresponds to another field.
	* @param cc : location, in the overall system, of the coefficient to be set to 1.
	* @param pos_cf : current position.
	*/
     void affecte_tau_one_coef_val_domain (Val_domain& so, int cc, int& pos_cf) const ;
     
     virtual int nbr_points_boundary (int, const Base_spectral&) const ;
     virtual void do_which_points_boundary (int, const Base_spectral&, Index**, int) const ;

     //friend ostream& operator<< (ostream& o, const Domain_critic_outer& so) ; ///< Display
public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
 * The \c Space_critic ; set the space with two critic domains, separated at \f$ x_{\rm lim}\f$.
 * \ingroup domain
 */
class Space_critic : public Space {
     public:
     /**
     * Standard constructor 
     * @param ttype [input] : the type of basis.
     * @param xl [input] : \f$ x_{\rm lim} \f$.
     * @param nbr_inner [input] : number of points in the inner domain.
     * @param nbr_outer [input] : number of points in the outer domain.
     */
	Space_critic (int ttype, double xl, const Dim_array& nbr_inner, const Dim_array& nbr_outer) ;
	Space_critic (FILE*) ; ///< Constructor from a file.
	virtual ~Space_critic() ;       
	virtual void save(FILE*) const ;

	/**
	* Sets a boundary condition at \f$ X=0\f$.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the boundary condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_bc_zero (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Sets a boundary condition at \f$ X=1 \f$.
	* @param syst : the \c System_of_eqs.
	* @param eq : the string describing the boundary condition.
	* @param nused : number of components of \c eq to be considered. All the components are used of it is -1.
	* @param pused : pointer on the indexes of the components to be considered. Not used of nused = -1 .
	*/
	void add_bc_one (System_of_eqs& syst, const char* eq, int nused=-1, Array<int>** pused=0x0)  ;
	/**
	* Adds an equation saying that one coefficient of a field is zero (at \f$ x_{\rm lim}\f$)
	* @param syst : the \c System_of_eqs.
	* @param f : the field
	* @param jtarget : the index \f$T\f$ of the mode that must vanish.
	*/
	void add_eq_zero_mode_center (System_of_eqs& syst, const char* f, int jtarget) ;
	     
    virtual Array<int> get_indices_matching_non_std(int, int) const ;
} ;
}
#endif
