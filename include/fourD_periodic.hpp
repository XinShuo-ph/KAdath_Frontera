/*
    Copyright 2017 Philippe Grandclement

    This file is part of Kadath.

    Kadath is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Kadath is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Kadath.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __fourD_PERIODIC_HPP_
#define __fourD_PERIODIC_HPP_

#include "space.hpp"

#define TO_PI 0
namespace Kadath {

/**
* Class for a spherical nucleus. The spacelike coordinates are \f$(r,\theta, \varphi)\f$.
* Time is the fourth dimension. The fields are supposed to be periodic.
* The numerical time goes either to \f$\pi\f$.
*
* \li The numerical coordinates are :
*
* \f$ 0 \leq x \leq 1 \f$
*
* \f$ 0 \leq \theta^\star \leq \pi/2 \f$
*
* \f$ 0 \leq \varphi^\star < 2\pi \f$
*
* \f$ 0 \leq t^\star \leq \quad \pi\f$

* \li Standard spherical coordinates :
*
* \f$ r = \alpha x \f$
*
* \f$ \theta = \theta^\star \f$
*
* \f$ \varphi = \varphi^\star \f$
* 
* \f$ t = t^\star / \omega\f$
*
* \ingroup domain
*/
class Domain_fourD_periodic_nucleus : public Domain {

 private:
  double alpha ; ///< Relates the numerical radius to the physical one.

  double ome ; ///< The pulsation.

  /**
   * Gives the type of time periodicity.
   * \li if 0 \f$ t^\star\f$ goes to \f$ \pi\f$.
   */
  int type_time ;
  double maxt ; ///< Upper bound of \f$ t^\star\f$ which is \f$\pi\f$ or \f$\pi/2\f$.

 public: 
   /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param radius : radius of the nucleus.
  * @param ome : pulsation.
  * @param nbr : number of points in each dimension.
  */
  Domain_fourD_periodic_nucleus (int num, int ttype, double radius, double ome, const Dim_array& nbr) ;
  Domain_fourD_periodic_nucleus (const Domain_fourD_periodic_nucleus& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_fourD_periodic_nucleus (int num, FILE* ff) ;

  virtual ~Domain_fourD_periodic_nucleus() ;
  virtual void save (FILE*) const ;

  private:    
    virtual void do_absol ()  const ;
    virtual void do_coloc () ;
    virtual void do_radius () const ;

  public:
     virtual bool is_in(const Point&xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point&) const;
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;
     /**
	* Returns omega
	*/ 
     double get_ome() const {return ome ;} ;

     virtual Val_domain mult_cos_phi (const Val_domain&) const ;
     virtual Val_domain mult_sin_phi (const Val_domain&) const ;
     virtual Val_domain mult_cos_theta (const Val_domain&) const ;
     virtual Val_domain mult_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_x (const Val_domain&) const ;


     /*
      * Generates a \c Val_domain, from another one assumed to be on a \c Polar_periodic_nucleus.
      * This is done in the coefficients space.
      * @param so : the input \c Val_domain
      */
     Val_domain translate (const Val_domain& so) const ;
     virtual Tensor change_basis_spher_to_cart (int dd, const Tensor&) const ;
public:
     virtual ostream& print (ostream& o) const ;
} ;


/**
* Class for a spherical shell. The spacelike coordinates are \f$(r,\theta, \varphi)\f$.
* 
* Time is the fourth dimension. The fields are supposed to be periodic.
* The numerical time goes either to \f$\pi\f$.
*
* \li The numerical coordinates are :
*
* \f$ -1 \leq x \leq 1 \f$
*
* \f$ 0 \leq \theta^\star \leq \pi/2 \f$
*
* \f$ 0 \leq \varphi^\star < 2\pi \f$
*
* \f$ 0 \leq t^\star \leq \quad \pi\f$

* \li Standard spherical coordinates :
*
* \f$ r = \alpha x + \beta\f$
*
* \f$ \theta = \theta^\star \f$
*
* \f$ \varphi = \varphi^\star \f$
* 
* \f$ t = t^\star / \omega\f$
*
* \ingroup domain
*/
class Domain_fourD_periodic_shell : public Domain {

 private:
  double alpha ; ///< Relates the numerical radius to the physical one.
  double beta ; ///< Relates the numerical radius to the physical one.


  double ome ; ///< The pulsation.
 
  /**
   * Gives the type of time periodicity.
   * \li if 0 \f$ t^\star\f$ goes to \f$ \pi\f$.
   */
  int type_time ;
  double maxt ; ///< Upper bound of \f$ t^\star\f$ which is \f$\pi\f$ or \f$\pi/2\f$.

 public: 
   /**
  * Standard constructor :
  * @param num : number of the domain (used by the \c Space).
  * @param ttype : Chebyshev or Legendre type of spectral expansion.
  * @param rin : inner radius of the shell.  
  * @param rout : outer radius of the shell.
  * @param ome : pulsation.
  * @param nbr : number of points in each dimension.
  */
  Domain_fourD_periodic_shell (int num, int ttype, double rin, double rout, double ome, const Dim_array& nbr) ;
  Domain_fourD_periodic_shell (const Domain_fourD_periodic_shell& so) ; ///< Copy constructor.
 /**
  * Constructor from a file
  * @param num : number of the domain (used by the \c Space).
  * @param ff: file containd the domain, generated by the save function.
  */
  Domain_fourD_periodic_shell (int num, FILE* ff) ;

  virtual ~Domain_fourD_periodic_shell() ;
  virtual void save (FILE*) const ;

  private:    
     virtual void do_absol ()  const ;
     virtual void do_coloc () ;
     virtual void do_radius () const ;
     virtual void do_cart ()  const ;

     virtual void set_cheb_base_x_cart(Base_spectral& so) const ;
     virtual void set_cheb_base_y_cart(Base_spectral& so) const ;
     virtual void set_legendre_base_x_cart(Base_spectral& so) const ;
     virtual void set_legendre_base_y_cart(Base_spectral& so) const ;


  public:
     virtual bool is_in(const Point&xx, double prec=1e-13) const ;
     virtual const Point absol_to_num(const Point&) const;
     virtual void do_der_abs_from_der_var(Val_domain** der_var, Val_domain** der_abs) const ;
     virtual Base_spectral mult (const Base_spectral&, const Base_spectral&) const ;

     virtual Val_domain mult_cos_phi (const Val_domain&) const ;
     virtual Val_domain mult_sin_phi (const Val_domain&) const ;
     virtual Val_domain mult_cos_theta (const Val_domain&) const ;
     virtual Val_domain mult_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_sin_theta (const Val_domain&) const ;
     virtual Val_domain div_xm1 (const Val_domain&) const ;    

     /*
      * Generates a \c Val_domain, from another one assumed to be on a \c Polar_periodic_nucleus.
      * This is done in the coefficients space.
      * @param so : the input \c Val_domain
      */
     Val_domain translate (const Val_domain& so) const ;
     virtual Tensor change_basis_spher_to_cart (int dd, const Tensor&) const ;

     /**
     * Computes the surface integral, at the outer boundary.
     * @param so : the field to be integrated.
     * @returns : an array being the time coefficients of the result (in case it is time dependant) 
     */
     Array<double> integ_outer_boundary (const Val_domain& so) const ;
public:
     virtual ostream& print (ostream& o) const ;
} ;

/**
 * The \c Space_fourD_periodic class fills the space with one 4d nucleus and several 4d shells, with a periodicity in time.
 * \ingroup domain
 */
class Space_fourD_periodic : public Space {
     public:
    	/**
     	* Standard constructor 
     	* @param ttype [input] : the type of basis.
	* @param omega [input] : the pulsation for the time dependance.
	* @param nbr [input] : number of points in each domain.
	* @param bounds [input] : radii of the various shells (and also determines the total number of domains).
	*/
	Space_fourD_periodic (int ttype, double omega, const Dim_array& nbr, const Array<double>& bounds) ;
	Space_fourD_periodic (FILE*) ; ///< Constructor from a file
	virtual ~Space_fourD_periodic() ;      
	virtual void save(FILE*) const ;

	double get_omega() const ;
} ;

}
#endif
