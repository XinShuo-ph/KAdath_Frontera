/*
    Copyright 2017 Philippe Grandclement

    This file is part of Kadath.

    Kadath is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Kadath is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Kadath.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __DIM_ARRAY_HPP_
#define __DIM_ARRAY_HPP_

#include "headcpp.hpp"

namespace Kadath {

class Dim_array_iterator;

/**
* Class for storing the dimensions of an array
*
* It simply consists of a list of integers, being the size of a given \c Array, in each
* dimension.
* \ingroup util
**/

class Dim_array  : public Memory_mapped_array<int> {
    public:
        using Steps_ptr_type = std::shared_ptr<Memory_mapped_array<int>>;
    private:
        mutable Steps_ptr_type steps;

        void compute_steps() const;

    public:
        using Data_type = Memory_mapped_array<int>;
        using size_type = int;
        /** Standard constructor
        * @param nd [input] number of dimensions. The sizes are not initialized.
        **/
        explicit Dim_array (int dim) : Data_type{dim}, steps{nullptr} {}
        Dim_array (const Dim_array &so): Data_type{so}, steps{nullptr} {}
        Dim_array (FILE*) ; ///< Constructor from a file (previously generated by the save member)

        /**
        * Read/write of the size of a given dimension.
        * @param i [input] dimension.
        */
        int& set(int i) {assert(i>=0); assert(i<size); return data[i];}
        /**
        * Read only of the size of a given dimension.
        * @param i [input] dimension.
        */
        int operator() (int i) const {assert(i>=0); assert(i<size); return data[i];}
        /**
        * Returns the number of dimensions.
        */
        int get_ndim() const {return size ;} ;
        /**
         * Assignement to annother \c Dim_array.
         */
        void operator= (const Dim_array& so) {assert (size==so.size);for (int i=0 ;i<size;i++) data[i] = so.data[i];}

        void swap(Dim_array & so) {}
        void save (FILE*) const ; ///< Save function

        Dim_array(Dim_array &&so) : Memory_mapped_array<int>{std::forward<Dim_array&&>(so)}, steps{std::move(so.steps)}
        {}
        Dim_array & operator=(Dim_array && so) {
            Memory_mapped_array<int>::operator=(std::forward<Dim_array&&>(so));
            steps = std::move(so.steps);
            return *this;
        }

        Dim_array_iterator make_iterator(int init=0) const;
        Steps_ptr_type const & get_steps() const {compute_steps(); return steps;}
} ;

ostream& operator<< (ostream&, const Dim_array&) ;
inline bool operator== (const Dim_array& a, const Dim_array& b) {
    bool res = (a.get_ndim()==b.get_ndim()) ? true : false ;
    if (res)
        for (int i=0 ; i<a.get_ndim() && res ; i++)
            res = (a(i) == b(i));
    return res ;
}
// Anti-comparison operator
inline  bool operator!= (const Dim_array& a, const Dim_array& b) {return !(a==b) ;}

inline void Dim_array::compute_steps() const {
    if(steps == nullptr) {
//        steps.reset(Memory_mapper<chosen_memory_map_type,boost_memory_pools_use>::get_memory<int>
//                                                                    (static_cast<std::size_t>(size+1)));
        steps.reset(new Memory_mapped_array<int>{size+1});
        auto & _steps = *steps;
        _steps[0] = 1;
        for(int i{0};i<size;i++) _steps[i+1] = _steps[i] * (*this)(i);
    }
}
}
#endif
